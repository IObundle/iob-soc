import os
import shutil
import sys
import importlib

import iob_colors
import if_gen
from mk_configuration import config_build_mk
import build_srcs
import verilog_tools
import mkregs
import blocks
import ios
import mk_configuration as mk_conf
import verilog_lint
import verilog_format
import sw_format
from pathlib import Path


class iob_module:
    """Generic class to describe a base iob-module"""

    ###############################################################
    # IOb module attributes: common to all iob-modules (subclasses)
    ###############################################################

    # Standard attributes common to all iob-modules
    name = "iob_module"  # Verilog module name (not instance name)
    csr_if = "iob"
    version = "1.0"  # Module version
    previous_version = None  # Module version
    setup_dir = ""  # Setup directory for this module
    build_dir = ""  # Build directory for this module
    confs = None  # List of configuration macros/parameters for this module
    autoaddr = True  # register address mode: True: automatic; False: manual
    rw_overlap = True  # overlap Read and Write register addresses
    regs = None  # List of registers for this module
    ios = None  # List of I/O for this module
    block_groups = None  # List of block groups for this module. Used for documentation.
    wire_list = None  # List of internal wires of the Verilog module. Used to interconnect module components.
    is_top_module = False  # Select if this module is the top module
    swregs = "hwsw"

    _initialized_attributes = (
        False  # Store if attributes have been initialized for this class
    )

    submodules = None  # List of submodules to setup
    interfaces = None  # List of interfaces to generate

    # List of setup purposes for this module. Also used to check if module has already been setup.
    _setup_purpose = None

    # Dictionary of headers generated by the `generate` method, and their purpose.
    __generated_headers = {}

    # Read-only dictionary with relation between the setup_purpose and the corresponding source folder
    PURPOSE_DIRS = {
        "hardware": "hardware/src",
        "simulation": "hardware/simulation/src",
        "fpga": "hardware/fpga/src",
    }

    def __init__(
        self,
        name="",
        description="default description",
        parameters={},
    ):
        """Constructor to build verilog instances.
        :param str name: Verilog instance name
        :param str description: Verilog instance description
        :param dict parameters: Verilog parameters
        """
        if not name:
            name = f"{self.name}_0"
        self.name = name
        self.description = description
        self.parameters = parameters

    ###############################################################
    # Methods NOT to be overriden by subclasses
    ###############################################################

    @staticmethod
    def find_modules(search_path="."):
        """Run a BFS for python modules under the given directory and append their paths to `sys.path`.
        This allows every module found to be imported.
        :param str search_path: Path to search for modules
        """
        dirs = [search_path]
        # Append PROJECT_ROOT to dirs, if exists
        for arg in sys.argv:
            if "PROJECT_ROOT" in arg:
                # Set a custom LIB directory
                dirs.append(arg.split("=")[1])
                break

        found_modules = []
        return_values = []
        # while there are dirs to search
        while len(dirs):
            nextDirs = []
            for parent in dirs:
                # Scan this dir
                for f in os.listdir(parent):
                    # if there is a dir, then save for next ittr
                    ff = os.path.join(parent, f)
                    if os.path.isdir(ff):
                        nextDirs.append(ff)
                        continue
                    # if there is a python module and has not been added before, then add it to sys.path
                    if f.endswith(".py") and f not in found_modules:
                        sys.path.append(parent)
                        found_modules.append(f)
            # once we've done all the current dirs then
            # we set up the next itter as the child dirs
            # from the current itter.
            dirs = nextDirs

    @classmethod
    def setup_as_top_module(cls):
        """Initialize the setup process for the top module.
        This method should only be called once, and only for the top module class.
        """
        cls.__global_pre_setup_tasks()
        cls.__setup(is_top_module=True)

    @classmethod
    def __global_pre_setup_tasks(cls):
        """Tasks to run before starting global setup process."""
        # Parse environment vars (if any)
        if "LIB_DIR" in os.environ:
            build_srcs.LIB_DIR = os.environ["LIB_DIR"]

        # Parse LIB_DIR argument
        for arg in sys.argv:
            if "LIB_DIR" in arg:
                # Set a custom LIB directory
                build_srcs.LIB_DIR = arg.split("=")[1]
                break

    @classmethod
    def __setup(cls, purpose="hardware", is_top_module=False):
        """
        purpose: Reason for setting up the module. Used to select between the standard destination locations.
        is_top_module: Select if this is the top module. This should only be enabled on the top module class.
        """
        # print(f"DEBUG: Setup: {cls.name}, purpose: {purpose}")  # DEBUG

        # Initialize empty list for purpose
        if cls._setup_purpose == None:
            cls._setup_purpose = []

        # Don't setup if module has already been setup for this purpose or for the "hardware" purpose.
        if purpose in cls._setup_purpose or "hardware" in cls._setup_purpose:
            return

        # Only init attributes if this is the first time we run setup
        if not cls._setup_purpose:
            cls.is_top_module = is_top_module
            cls.__init_attributes()

        # Create build directory this is the top module class, and is the first time setup
        if is_top_module and not cls._setup_purpose:
            cls.__create_build_dir()

        cls._setup_purpose.append(purpose)

        cls.__setup_submodules_and_interfaces(cls.submodules, cls.interfaces)
        cls._pre_setup()
        cls.__intermediate_setup()
        cls._post_setup()
        cls.__final_setup()

    @classmethod
    def __init_attributes(cls):
        """Private method to initialize attributes of the class
        This method is automatically called by the `setup` method.
        """
        # Only run this method if attributes have not yet been initialized
        if cls._initialized_attributes:
            return
        cls._initialized_attributes = True

        # Initialize empty lists for attributes (We can't initialize in the attribute declaration because it would cause every subclass to reference the same list)
        cls.confs = []
        cls.regs = []
        cls.ios = []
        cls.block_groups = []
        cls.submodules = []
        cls.interfaces = []
        cls.wire_list = []
        cls._init_attributes()

        # Set the build directory in the `iob_module` superclass, so everyone has access to it
        if cls.is_top_module:
            # Auto-fill build directory if its not set
            if not cls.build_dir:
                iob_module.build_dir = f"../{cls.name}_{cls.version}"
            else:
                iob_module.build_dir = cls.build_dir

        # Copy build directory from the `iob_module` superclass
        cls.build_dir = iob_module.build_dir

        # Copy current version to previous version if it is not set
        if not cls.previous_version:
            cls.previous_version = cls.version

    @classmethod
    def init_attr(cls, attribute_name, default_value):
        """Initialize the given attribute if it has not been initialized yet."""
        if not hasattr(cls, attribute_name):
            setattr(cls, attribute_name, default_value)

    ###############################################################
    # Methods commonly overriden by subclasses
    ###############################################################

    @classmethod
    def _init_attributes(cls):
        """Default method to init attributes does nothing.
        Override this method in subclasses to initialize class attributes.
        For example, to initialize the `confs` list.
        """
        pass

    @classmethod
    def _pre_setup(cls):
        """Default method to pre-setup does nothing.
        Override this method in subclasses to do pre-setup tasks.
        The pre-setup runs after the `_init_attributes` method has been executed for this class and all of its submodules.
        Use this method when the tasks need to modify attributes of this class based on attributes of its submodules.
        For example, to update the `ios` of the current core based on the `ios` of the submodules.
        """
        pass

    @classmethod
    def _post_setup(cls):
        """Default method to post-setup does nothing.
        Override this method in subclasses to do post-setup tasks.
        The post-setup runs after the build directory has been created.
        For example, to modify files that were generated in the build directory by the setup process.
        """
        pass

    ###############################################################
    # Private methods
    ###############################################################

    @classmethod
    def __intermediate_setup(cls):
        """Launch post(-specific)-setup tasks"""
        # Setup flows (copy LIB files)
        build_srcs.flows_setup(cls)

        # Copy sources from the module's setup dir (and from its superclasses)
        cls.__copy_srcs()

        # Auto-add common module macros and submodules
        cls.__auto_add_settings()

        # Generate hw, sw and doc files
        mkregs_obj, reg_table = cls.__build_regs_table()
        if "hw" in cls.swregs:
            cls.__generate_hw(mkregs_obj, reg_table)
        if "sw" in cls.swregs:
            cls.__generate_sw(mkregs_obj, reg_table)
        cls.__generate_doc(mkregs_obj, reg_table)

        # Run `*_setup.py` python scripts
        cls.__run_setup_files()

    @classmethod
    def __final_setup(cls):
        if cls.is_top_module:
            # Replace Verilog snippet includes
            cls.__replace_snippet_includes()
            # Clean duplicate sources in `hardware/src` and its subfolders (like `hardware/simulation/src`)
            cls.__remove_duplicate_sources()
            # Run linter and formatters
            cls.__lint_and_format()

    @classmethod
    def __lint_and_format(cls):
        """Run Linters and Formatters in setup and build directories."""
        run_verilog_lint = True
        run_verilog_format = True

        # Parse environment vars (if any)
        if "DISABLE_LINT" in os.environ:
            run_verilog_lint = not bool(os.environ["DISABLE_LINT"])
        if "DISABLE_FORMAT" in os.environ:
            run_verilog_format = not bool(os.environ["DISABLE_FORMAT"])

        # Parse arguments (if any)
        for arg in sys.argv:
            if "DISABLE_LINT" in arg:
                run_verilog_lint = not bool(arg.split("=")[1])
            elif "DISABLE_FORMAT" in arg:
                run_verilog_format = not bool(arg.split("=")[1])

        # Find Verilog sources and headers from build dir
        verilog_headers = []
        verilog_sources = []
        for path in Path(os.path.join(cls.build_dir, "hardware")).rglob("*.vh"):
            # Skip specific Verilog headers
            if path.name.endswith("version.vh") or "test_" in path.name:
                continue
            verilog_headers.append(str(path))
            # print(str(path))
        for path in Path(os.path.join(cls.build_dir, "hardware")).rglob("*.v"):
            verilog_sources.append(str(path))
            # print(str(path))

        # Run Verilog linter
        if run_verilog_lint:
            verilog_lint.lint_files(verilog_headers + verilog_sources)

        # Run Verilog formatter
        if run_verilog_format:
            verilog_format.format_files(
                verilog_headers + verilog_sources,
                os.path.join(build_srcs.LIB_DIR, "scripts/verible-format.rules"),
            )

        # Run Python formatter
        sw_format.run_formatter("black")
        sw_format.run_formatter("black", cls.build_dir)

        # Run C formatter
        sw_format.run_formatter("clang")
        sw_format.run_formatter("clang", cls.build_dir)

    @classmethod
    def __auto_add_settings(cls):
        """Auto-add settings like macros and submodules to the module"""
        # Auto-add 'VERSION' macro if it doesn't exist.
        # But only if this module has at least one other configuration aswell
        # (to prevent lots of LIB modules with only the `VERSION` macron)
        if cls.confs:
            for macro in cls.confs:
                if macro["name"] == "VERSION":
                    break
            else:
                cls.confs.append(
                    {
                        "name": "VERSION",
                        "type": "M",
                        "val": "16'h" + build_srcs.version_str_to_digits(cls.version),
                        "min": "NA",
                        "max": "NA",
                        "descr": "Product version. This 16-bit macro uses nibbles to represent decimal numbers using their binary values. The two most significant nibbles represent the integral part of the version, and the two least significant nibbles represent the decimal part. For example V12.34 is represented by 0x1234.",
                    }
                )
        if cls.regs:
            # Auto-add iob_ctls module
            if cls.name != "iob_ctls":
                from iob_ctls import iob_ctls

                iob_ctls.__setup(purpose=cls.__get_setup_purpose())
            ## Auto-add iob_s_port.vh and iob_s_portmap.vh
            cls.__generate({"interface": "iob"}, purpose=cls.__get_setup_purpose())

    @classmethod
    def __build_regs_table(cls, no_overlap=False):
        """Build registers table.
        :returns mkregs mkregs_obj: Instance of mkregs class
        :returns list reg_table: Register table generated by `get_reg_table` method of `mkregs_obj`
        """
        # Don't create regs table if module does not have regs
        if not cls.regs:
            return None, None

        # Make sure 'general' registers table exists
        general_regs_table = next((i for i in cls.regs if i["name"] == "general"), None)
        if not general_regs_table:
            general_regs_table = {
                "name": "general",
                "descr": "General Registers.",
                "regs": [],
            }
            cls.regs.append(general_regs_table)

        # Add 'VERSION' register if this is the first time we are setting up this core
        # (The register will already be present on subsequent setups)
        if len(cls._setup_purpose) < 2:
            # Auto add 'VERSION' register in 'general' registers table if it doesn't exist
            # If it does exist, give an error
            for reg in general_regs_table["regs"]:
                if reg["name"] == "VERSION":
                    raise Exception(
                        cls.name + ": Register 'VERSION' is reserved. Please remove it."
                    )
            else:
                general_regs_table["regs"].append(
                    {
                        "name": "VERSION",
                        "type": "R",
                        "n_bits": 16,
                        "rst_val": build_srcs.version_str_to_digits(cls.version),
                        "addr": -1,
                        "log2n_items": 0,
                        "autoreg": True,
                        "descr": "Product version.  This 16-bit register uses nibbles to represent decimal numbers using their binary values. The two most significant nibbles represent the integral part of the version, and the two least significant nibbles represent the decimal part. For example V12.34 is represented by 0x1234.",
                    }
                )

        # Create an instance of the mkregs class inside the mkregs module
        # This instance is only used locally, not affecting status of mkregs imported in other functions/modules
        mkregs_obj = mkregs.mkregs()
        mkregs_obj.config = cls.confs
        # Get register table
        reg_table = mkregs_obj.get_reg_table(cls.regs, cls.rw_overlap, cls.autoaddr)

        return mkregs_obj, reg_table

    @classmethod
    def __generate_hw(cls, mkregs_obj, reg_table):
        """Generate common hardware files"""
        if cls.regs:
            mkregs_obj.write_hwheader(
                reg_table, cls.build_dir + "/hardware/src", cls.name
            )
            mkregs_obj.write_lparam_header(
                reg_table, cls.build_dir + "/hardware/simulation/src", cls.name
            )
            mkregs_obj.write_hwcode(
                reg_table, cls.build_dir + "/hardware/src", cls.name
            )

        if cls.confs:
            mk_conf.params_vh(cls.confs, cls.name, cls.build_dir + "/hardware/src")

            mk_conf.conf_vh(cls.confs, cls.name, cls.build_dir + "/hardware/src")

        if cls.ios:
            ios.generate_ports(cls.ios, cls.name, cls.build_dir + "/hardware/src")

    @classmethod
    def __generate_sw(cls, mkregs_obj, reg_table):
        """Generate common software files"""
        os.makedirs(cls.build_dir + "/software/src", exist_ok=True)
        if cls.regs:
            mkregs_obj.write_swheader(
                reg_table, cls.build_dir + "/software/src", cls.name
            )
            mkregs_obj.write_swcode(
                reg_table, cls.build_dir + "/software/src", cls.name
            )
            mkregs_obj.write_swheader(
                reg_table, cls.build_dir + "/software/src", cls.name
            )
        mk_conf.conf_h(cls.confs, cls.name, cls.build_dir + "/software/src")

    @classmethod
    def __generate_doc(cls, mkregs_obj, reg_table):
        """Generate common documentation files"""
        if cls.is_top_module:
            mk_conf.generate_confs_tex(cls.confs, cls.build_dir + "/document/tsrc")
            ios.generate_ios_tex(cls.ios, cls.build_dir + "/document/tsrc")
            if cls.regs:
                mkregs_obj.generate_regs_tex(
                    cls.regs, reg_table, cls.build_dir + "/document/tsrc"
                )
            blocks.generate_blocks_tex(
                cls.block_groups, cls.build_dir + "/document/tsrc"
            )

    @classmethod
    def __remove_duplicate_sources(cls):
        """Remove sources in the build directory from subfolders that exist in `hardware/src`"""
        # Go through all subfolders defined in PURPOSE_DIRS
        for subfolder in cls.PURPOSE_DIRS.values():
            # Skip hardware folder
            if subfolder == "hardware/src":
                continue

            # Get common srcs between `hardware/src` and current subfolder
            common_srcs = cls.__find_common_deep(
                os.path.join(cls.build_dir, "hardware/src"),
                os.path.join(cls.build_dir, subfolder),
            )
            # Remove common sources
            for src in common_srcs:
                os.remove(os.path.join(cls.build_dir, subfolder, src))

    @classmethod
    def __replace_snippet_includes(cls):
        verilog_tools.replace_includes(cls.setup_dir, cls.build_dir)

    @classmethod
    def __run_setup_files(cls):
        flows_setup_files = {
            "sim": cls.setup_dir + "/hardware/simulation/sim_setup.py",
            "fpga": cls.setup_dir + "/hardware/fpga/fpga_setup.py",
            "emb": cls.setup_dir + "/software/sw_setup.py",
            "doc": cls.setup_dir + "/document/doc_setup.py",
        }
        for flow, filepath in flows_setup_files.items():
            # Skip if file does not exist
            if not os.path.isfile(filepath):
                continue

            module_name = os.path.basename(filepath).split(".")[0]
            spec = importlib.util.spec_from_file_location(module_name, filepath)
            module = importlib.util.module_from_spec(spec)
            sys.modules[module_name] = module
            # Define setup_module object, corresponding to this class
            vars(module)["setup_module"] = cls
            # Execute setup file
            spec.loader.exec_module(module)

    @classmethod
    def __setup_submodules_and_interfaces(cls, submodules, interfaces):
        """
        Generate or run setup functions for the interfaces/submodules in the given submodules list.
        """

        def setup(entry_list, func2call):
            for entry in entry_list:
                _entry = entry
                setup_options = {}

                # Split entry from its setup options (if it is a tuple)
                if type(entry) == tuple:
                    _entry = entry[0]
                    setup_options = entry[1]

                # Add 'hardware' purpose by default
                if "purpose" not in setup_options:
                    setup_options["purpose"] = "hardware"

                # Don't setup entrys that have a purpose different than
                # "hardware" when this class is not the top module
                if not cls.is_top_module and setup_options["purpose"] != "hardware":
                    continue

                # If the entry purpose is hardware, change that purpose to match the purpose of the current class.
                # (If we setup the current class for simulation, then we want the entrys for simulation aswell)
                if setup_options["purpose"] == "hardware":
                    setup_options["purpose"] = cls.__get_setup_purpose()

                func2call(_entry, setup_options)

        def setup_submodule(submodule, setup_options):
            assert (
                type(submodule) is not dict
            ), f"{iob_colors.FAIL}Interfaces are no longer supported in submodules list of {cls.name}: {submodule}. Please use the new `interfaces` list attribute.{iob_colors.ENDC}"
            assert issubclass(
                submodule, iob_module
            ), f"{iob_colors.FAIL}Unknown type in submodules of {cls.name}: {submodule}{iob_colors.ENDC}"
            submodule.__setup(**setup_options)

        def setup_interface(interface, setup_options):
            assert (
                type(interface) is dict
            ), f"{iob_colors.FAIL}Unknown type in interfaces of {cls.name}: {interface}{iob_colors.ENDC}"
            cls.__generate(interface, **setup_options)

        setup(submodules, setup_submodule)
        setup(interfaces, setup_interface)

    @classmethod
    def __generate(cls, vs_dict, purpose="hardware"):
        """
        Generate a Verilog snippet with `if_gen.py`.
        """
        dest_dir = os.path.join(cls.build_dir, cls.__get_purpose_dir(purpose))

        # set prefixes if they do not exist
        if not "file_prefix" in vs_dict:
            vs_dict["file_prefix"] = ""
        if not "port_prefix" in vs_dict:
            vs_dict["port_prefix"] = ""
        if not "wire_prefix" in vs_dict:
            vs_dict["wire_prefix"] = ""
        if not "ports" in vs_dict:
            vs_dict["ports"] = []
        if not "mult" in vs_dict:
            vs_dict["mult"] = 1
        if not "widths" in vs_dict:
            vs_dict["widths"] = {}

        # Skip unknown interfaces
        if vs_dict["interface"] not in if_gen.if_names:
            print(
                f"{iob_colors.WARNING}Unknown interface '{vs_dict['interface']}'.{iob_colors.ENDC}"
            )
            return

        # Generate interface
        if_gen.gen_if(
            vs_dict["interface"],
            vs_dict["file_prefix"],
            vs_dict["port_prefix"],
            vs_dict["wire_prefix"],
            vs_dict["ports"],
            vs_dict["mult"],
            vs_dict["widths"],
        )

        # move all .vs files from current directory to out_dir
        for file in os.listdir("."):
            if file.endswith(".vs"):
                os.rename(file, f"{dest_dir}/{file}")

    @classmethod
    def __get_setup_purpose(cls):
        """Get the purpose of the latest setup.
        :returns str setup_purpose: The latest setup purpose
        """
        if len(cls._setup_purpose) < 1:
            raise Exception(
                f"{iob_colors.FAIL}Module has not been setup!{iob_colors.ENDC}"
            )
        # Return the latest purpose
        return cls._setup_purpose[-1]

    @classmethod
    def __get_purpose_dir(cls, purpose):
        """Get output directory based on the purpose given."""
        assert (
            purpose in cls.PURPOSE_DIRS
        ), f"{iob_colors.FAIL}Unknown purpose {purpose}{iob_colors.ENDC}"
        return cls.PURPOSE_DIRS[purpose]

    @classmethod
    def __create_build_dir(cls):
        """Create build directory. Must be called from the top module."""
        assert (
            cls.is_top_module
        ), f"{iob_colors.FAIL}Module {cls.name} is not a top module!{iob_colors.ENDC}"
        os.makedirs(cls.build_dir, exist_ok=True)
        config_build_mk(cls)
        # Create hardware directories
        os.makedirs(f"{cls.build_dir}/hardware/src", exist_ok=True)
        os.makedirs(f"{cls.build_dir}/hardware/simulation/src", exist_ok=True)
        os.makedirs(f"{cls.build_dir}/hardware/fpga/src", exist_ok=True)

        shutil.copyfile(
            f"{build_srcs.LIB_DIR}/build.mk", f"{cls.build_dir}/Makefile"
        )  # Copy generic MAKEFILE

    @classmethod
    def __copy_srcs(cls, exclude_file_list=[], highest_superclass=None):
        """Copy module sources to the build directory from every subclass in between `iob_module` and `cls`, inclusive.
        The function will not copy sources from classes that have no setup_dir (empty string)
        cls: Lowest subclass
        (implicit: iob_module: highest subclass)
        :param list exclude_file_list: list of strings, each string representing an ignore pattern for the source files.
                                       For example, using the ignore pattern '*.v' would prevent from copying every Verilog source file.
                                       Note, if want to ignore a file that is going to be renamed with the new core name,
                                       we would still use the old core name in the ignore patterns.
                                       For example, if we dont want it to generate the 'new_name_firmware.c' based on the 'old_name_firmware.c',
                                       then we should add 'old_name_firmware.c' to the ignore list.
        :param class highest_superclass: If specified, only copy sources from this subclass and up to specified class. By default, highest_superclass=iob_module.
        """
        previously_setup_dirs = []
        # Select between specified highest_superclass or this one (iob_module)
        highest_superclass = highest_superclass or __class__

        # List of classes, starting from highest superclass (iob_module), down to lowest subclass (cls)
        classes = cls.__mro__[cls.__mro__.index(highest_superclass) :: -1]

        # Go through every subclass, starting for highest superclass to the lowest subclass
        for module_class in classes:
            # Skip classes without setup_dir
            if not module_class.setup_dir:
                continue

            # Skip class if we already setup its directory (it may have inherited the same dir from the superclass)
            if module_class.setup_dir in previously_setup_dirs:
                continue

            previously_setup_dirs.append(module_class.setup_dir)

            # Files that should always be copied
            dir_list = [
                "hardware/src",
                "software",
            ]
            # Files that should only be copied if it is top module
            if cls.is_top_module:
                dir_list += [
                    "hardware/simulation",
                    "hardware/fpga",
                    "hardware/syn",
                    "hardware/lint",
                ]

            # Copy sources
            for directory in dir_list:
                # Skip this directory if it does not exist
                if not os.path.isdir(os.path.join(module_class.setup_dir, directory)):
                    continue

                # If we are handling the `hardware/src` directory,
                # copy to the correct destination based on `_setup_purpose`.
                if directory == "hardware/src":
                    dst_directory = cls.__get_purpose_dir(cls.__get_setup_purpose())
                else:
                    dst_directory = directory

                # Copy tree of this directory, renaming files, and overriding destination ones.
                shutil.copytree(
                    os.path.join(module_class.setup_dir, directory),
                    os.path.join(cls.build_dir, dst_directory),
                    dirs_exist_ok=True,
                    copy_function=cls.__copy_with_rename(module_class.name, cls.name),
                    ignore=shutil.ignore_patterns(*exclude_file_list),
                )

            # Copy document directory if cls is the top module and it has documentation
            if cls.is_top_module and os.path.isdir(
                os.path.join(module_class.setup_dir, "document")
            ):
                shutil.copytree(
                    os.path.join(module_class.setup_dir, "document"),
                    os.path.join(cls.build_dir, "document"),
                    dirs_exist_ok=True,
                    ignore=shutil.ignore_patterns(*exclude_file_list),
                )

    @staticmethod
    def __find_common_deep(path1, path2):
        """Find common files (recursively) inside two given directories
        Taken from: https://stackoverflow.com/a/51625515
        :param str path1: Directory path 1
        :param str path2: Directory path 2
        """
        return set.intersection(
            *(
                set(
                    os.path.relpath(os.path.join(root, file), path)
                    for root, _, files in os.walk(path)
                    for file in files
                )
                for path in (path1, path2)
            )
        )

    @staticmethod
    def __copy_with_rename(old_core_name, new_core_name):
        """Creates a function that:
        - Renames any '<old_core_name>' string inside the src file and in its filename, to the given '<new_core_name>' string argument.
        """

        def copy_func(src, dst):
            dst = os.path.join(
                os.path.dirname(dst),
                os.path.basename(
                    dst.replace(old_core_name, new_core_name).replace(
                        old_core_name.upper(), new_core_name.upper()
                    )
                ),
            )
            # print(f"### DEBUG: {src} {dst}")
            try:
                file_perms = os.stat(src).st_mode
                with open(src, "r") as file:
                    lines = file.readlines()
                for idx in range(len(lines)):
                    lines[idx] = (
                        lines[idx]
                        .replace(old_core_name, new_core_name)
                        .replace(old_core_name.upper(), new_core_name.upper())
                    )
                with open(dst, "w") as file:
                    file.writelines(lines)
            except:
                shutil.copyfile(src, dst)
            # Set file permissions equal to source file
            os.chmod(dst, file_perms)

        return copy_func
