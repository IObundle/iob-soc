<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>README.html</title>

</head>

<body>

<h1 id="iob-soc">IOb-SoC</h1>
<p>SoC template comprising a RISC-V processor (iob-rv32), an SRAM memory subsystem, an UART (iob-uart), and optional caches and AXI4 connection to external DDR.</p>
<h2 id="clone-the-repository">Clone the repository</h2>
<p><code>git clone git@github.com:IObundle/iob-soc.git</code></p>
<p>Ssh access is mandadory so that submodules can be updated.</p>
<h2 id="update-submodules">Update submodules</h2>
<p><code>git submodule update --init --recursive</code></p>
<h2 id="edit-the-system-configuration-file-rtlsystem.mk">Edit the system configuration file: rtl/system.mk</h2>
<p>To configure IOb-SoC the following parameters are availble:</p>
<p>FIRM_ADDR_W: log2 size of user program and data space, from 1st instruction at address 0 to the stack end at address 2<sup>FIRM_ADDR_W</sup>-1</p>
<p>SRAM_ADDR_W: log2 size of SRAM, addresses from 0 to 2<sup>SRAM_ADDR_W</sup>-1</p>
<p>USE_DDR: assign to 1 if DDR access is needed or to 0 otherwsie. Instruction and data L1 caches will be placed in the design, connected to an L2 cache, which in turn connects to an external DDR controller.</p>
<p>RUN_DDR:= assign to 1 if the program runs from the DDR memory and 0 otherwise. This parameter is ignored if USE_DDR=0. If USE_DDR=1 and RUN_DDR=1, the SRAM memory can be accessed when the address MSB is 1. If USE_DDR=1 and RUN_DDR=0, the DDR is used to store data only; it can be accessed when the address MSB is 1.</p>
<p>DDR_ADDR_W: log2 size of DDR, addresses from 0 to 2<sup>DDR_ADDR_W</sup>-1</p>
<p>USE_BOOT: assign to 1 to load a program received by the UART and boot from it, or to 0 otherwise.</p>
<p>BOOTROM_ADDR_W: log2 size of the boot ROM, which should be sufficient to hold the bootloader program and data.</p>
<p>N_SLAVES: Number of slaves (peripherals).</p>
<p>Then, assign peripheral IDs serially: 0, 1, 2, etc, for example: UART:=0 SPI:=1 ...</p>
<p>SIM_DIR: path to a directory containing scripts for running RTL simulation.</p>
<p>FPGA_DIR: path to a directory containing scripts for compiling and running the design on an FPGA.</p>
<p>FPGA_COMPILER_SERVER: IP address of a machine where the FPGA tools are installed</p>
<p>FPGA_BOARD_SERVER: IP address of a machine to which an FPGA board is attached and where the design will run.</p>
<p>ASIC_DIR: path to a directory containing scripts for compiling the design for an ASIC. #Peripheral list (must match respective submodule name) PERIPHERALS:=UART</p>
<h1 id="rtl-simulator">RTL simulator</h1>
<p>SIMULATOR:=icarus #SIMULATOR:=modelsim #SIMULATOR:=ncsim</p>
<h1 id="fpga">FPGA</h1>
<p>FPGA_BOARD:=AES-KU040-DB-G #FPGA_BOARD:=CYCLONEV-GT-DK FPGA_COMPILER_SERVER=$(PUDIM)</p>
<p>ifeq (<span class="math inline">(<em>F</em><em>P</em><em>G</em><em>A</em><sub><em>B</em></sub><em>O</em><em>A</em><em>R</em><em>D</em>),<em>A</em><em>E</em><em>S</em> − <em>K</em><em>U</em>040 − <em>D</em><em>B</em> − <em>G</em>)<em>F</em><em>P</em><em>G</em><em>A</em><sub><em>B</em></sub><em>O</em><em>A</em><em>R</em><em>D</em><sub><em>S</em></sub><em>E</em><em>R</em><em>V</em><em>E</em><em>R</em>=</span>(BABA) else ifeq (<span class="math inline">(<em>F</em><em>P</em><em>G</em><em>A</em><sub><em>B</em></sub><em>O</em><em>A</em><em>R</em><em>D</em>),<em>C</em><em>Y</em><em>C</em><em>L</em><em>O</em><em>N</em><em>E</em><em>V</em> − <em>G</em><em>T</em> − <em>D</em><em>K</em>)<em>F</em><em>P</em><em>G</em><em>A</em><sub><em>B</em></sub><em>O</em><em>A</em><em>R</em><em>D</em><sub><em>S</em></sub><em>E</em><em>R</em><em>V</em><em>E</em><em>R</em>=</span>(PUDIM) endif</p>
<h1 id="asic-node">ASIC node</h1>
<p>ASIC_NODE:=umc130</p>
<h1 id="doc_type">DOC_TYPE</h1>
<p>DOC_TYPE:=presentation</p>
<h1 id="server-list">server list</h1>
<p>PUDIM:=146.193.44.48 BABA:=146.193.44.179</p>
<h2 id="simulate">Simulate</h2>
<pre><code>make sim</code></pre>
<h2 id="compile-and-configure-fpga">Compile and configure FPGA</h2>
<pre><code>make fpga</code></pre>
<h2 id="load-and-run-firmware">Load and run firmware</h2>
<pre><code>make load-firmware</code></pre>
<h2 id="run-firmware-only">Run firmware only</h2>
<pre><code>make run-firmware</code></pre>
<h2 id="implement-asic">Implement ASIC</h2>
<pre><code>make asic</code></pre>
<h2 id="instructions-for-installing-the-risc-v-gnu-compiler-toolchain">Instructions for Installing the RISC-V GNU Compiler Toolchain</h2>
<h3 id="get-sources">Get sources</h3>
<pre><code>git clone https://github.com/riscv/riscv-gnu-toolchain
cd riscv-gnu-toolchain
git submodule update --init --recursive
git checkout &lt;stable tag&gt;
git submodule update --init --recursive</code></pre>
<h3 id="prerequisites">Prerequisites</h3>
<p>For Ubuntu OS and its variants:</p>
<pre><code>sudo apt install autoconf automake autotools-dev curl python3 libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-dev libexpat-dev</code></pre>
<p>For CentOS and its variants:</p>
<pre><code>sudo yum install autoconf automake python3 libmpc-devel mpfr-devel gmp-devel gawk  bison flex texinfo patchutils gcc gcc-c++ zlib-devel expat-devel</code></pre>
<h3 id="instalation">Instalation</h3>
<pre><code>sudo ./configure --prefix=path/to/riscv --enable-multilib
sudo make</code></pre>
<h3 id="compilation">Compilation</h3>
<pre><code>path/to/riscv/riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 &lt;C sources&gt; -o &lt;exec&gt;</code></pre>
<h3 id="supporting-32-bit-applications">Supporting 32-bit applications</h3>
<p>Use symbolic links:</p>
<pre><code>sudo ln -s riscv64-unknown-elf-gcc riscv32-unknown-elf-gcc
sudo ln -s riscv64-unknown-elf-objcopy riscv32-unknown-elf-objcopy</code></pre>

</body>
</html>
